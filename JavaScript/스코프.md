# scope

```JavaScript
var x = 1;

function foo () {
	var x = 0;
}

console.log(x);
```

console은 `foo 함수의 바깥에 있는 x`와 `foo 함수 내부에 있는 x` 중 어느 변수의 값을 출력할까? 정답은 1이다. 콘솔과 가장 가까이에 있는 것은 foo 함수 내부에 있는 x지만 콘솔이 0을 출력하는 일은 **절대** 없다. foo 함수의 x는 foo 함수의 영역 안에서만 유효하기 때문.

**왜 foo 함수 안에서만 유효할까?** 함수 안에 선언된 x는 **지역 스코프**를 가지기 때문이다. 함수 블록의 내부만이 자신의 영역이고, 여기서만 유효한 존재이기 때문에 함수 바깥에서 이 x를 참조하려고 하면 참조할 수 없다. 그럼 바깥에 선언된 변수 x는 어떤 스코프를 가질까? 이 변수는 **전역 스코프**를 가진다. 말 그대로 코드의 가장 바깥 영역이 x의 스코프이기 때문에 모든 곳에서 이 x를 참조할 수 있다.

이 두 개의 x라는 변수 간에는 무슨 차이가 있었길래 각각 다른 영역을 가지게 됐을까? 바로 선언된 위치라는 차이가 있다. **자바스크립트 엔진은 x라는 변수가 무엇인지, 어떤 변수를 참조해야 할지 결정할 때 스코프에 따라서 결정하는데** 이 부분에 위치가 많은 영향을 끼친다. 위치에 따라 스코프가 달라짐.

```javaScript
var x = 1;

function foo () {
	var x = 0;

    function bar () {
		var x = 2;
        console.log(x); // (?)
	}
}

```

여기서 console은 어떤 x를 참조할까? 이 상황에서 콘솔은 모든 x에 접근 가능하다. bar 안에 x라는 변수가 없었으면 foo에 선언된 x를 참조해 0을 출력했을 것이고, foo라는 함수에 x라는 변수가 없었다면 전역 스코프를 가지고 있는 x를 참조해 1을 출력했을 것임.

그 이유는 **지역 변수는 자신의 지역 스코프와 자신의 하위 스코프에서 유효하기 때문이다.** 자바스크립트 엔진은 x를 찾을 때 다음과 같은 순서로 x를 찾음.

`bar 함수 스코프` -> `foo 함수 스코프` -> `전역 스코프`

이러한 순서대로 하위에서 상위 방향으로 이동하면서 변수를 찾는다(스코프 체인). 그렇기 때문에 상위에 있는 변수를 참조할 수 있게 된 것. 즉, foo 함수에 선언된 x는 foo와 bar라는 함수 안에서 접근 가능함. 반대로 foo 함수의 바깥에서 foo 함수에 선언된 x를 참조할 수는 없다. 이는 상위에서 하위 방향으로 식별자를 검색해야 가능한 일.

**렉시컬 환경이라는 것은 쉽게 말해 문맥을 뜻함**. 문장을 읽을 때 문맥을 파악해서 '이', '그'라는 지시대명사의 뜻을 파악할 수 있는 것처럼 자바스크립트 엔진도 이러한 문맥을 파악해야 함.

```javascript
var x = 1;

if (true) {
var x = 6;
...
}

console.log(x);

```

여기서 콘솔은 6을 출력함. 그 이유는 var의 특성 때문. **var는 함수에 의해서만 지역 스코프를 생성한다.** 그렇기 때문에 if 같은 블록 레벨의 스코프에서는 영역을 생성하지 않음. var는 이렇게 예측하지 못한 상황을 발생시키기 때문에 사용을 지양하고, let과 const를 사용하는 것이 좋다. let과 const는 블록 레벨 스코프를 영역으로 인정하기 때문에 다음과 같이 결과를 예측하기가 쉽다.

```javascript
var x = 10;

if (true) {
  let x = 9;
}

console.log(x); // 10
```

자바스크립트는 **렉시컬 스코프를 따르기 때문에 함수를 어디에서 정의했는지가 중요함.** 함수가 어디에서 호출되었는가는 영향을 끼치지 않음. 함수가 어디서 정의되었는지에 따라 어떤 변수가 주변에 있었는지, 어디에서 이 함수가 정의되었는지 즉, 함수가 정의됐을 때의 **상위 스코프**를 기억한다. 함수가 호출 될 때도 이 상위 스코프를 항상 기억함.

<br>

**참고 문서**

모던 자바스크립트 딥다이브
